//***********************************************************************************************
//  ESP32 Emotional Pet with FluxGarage RoboEyes + TFT_eSPI
//  
//  Hardware: ESP32 S3 N16R8 PSRAM + TFT 2.4" 320x240 ILI9341
//  
//  T√≠nh nƒÉng:
//  - T√≠ch h·ª£p th∆∞ vi·ªán FluxGarage RoboEyes v·ªõi TFT_eSPI
//  - Animation m∆∞·ª£t m√† v·ªõi auto-blink v√† idle mode
//  - Nhi·ªÅu tr·∫°ng th√°i c·∫£m x√∫c v√† hi·ªáu ·ª©ng
//  - Performance cao h∆°n v·ªõi TFT_eSPI
//  
//  L·ªánh Serial:
//  :happy - Vui v·∫ª
//  :angry - T·ª©c gi·∫≠n  
//  :tired - M·ªát m·ªèi
//  :normal - B√¨nh th∆∞·ªùng
//  :confused - B·ªëi r·ªëi (animation)
//  :laugh - C∆∞·ªùi (animation)
//  :blink - Ch·ªõp m·∫Øt
//  :wink - Nh√°y m·∫Øt
//  :look:N/NE/E/SE/S/SW/W/NW - Nh√¨n theo h∆∞·ªõng
//  :idle:1/0 - B·∫≠t/t·∫Øt idle mode
//  :auto:1/0 - B·∫≠t/t·∫Øt auto blink
//  :cyclops:1/0 - Ch·∫ø ƒë·ªô m·ªôt m·∫Øt
//  :curious:1/0 - Ch·∫ø ƒë·ªô t√≤ m√≤
//
//***********************************************************************************************

#include <TFT_eSPI.h>
#include <SPI.h>

// TFT_eSPI instance
TFT_eSPI tft = TFT_eSPI(320, 240); // Landscape mode 320x240

// Display Adapter ƒë·ªÉ FluxGarage RoboEyes ho·∫°t ƒë·ªông v·ªõi TFT_eSPI
// Case che b√™n tr√°i 40px, b√™n ph·∫£i 20px -> d·ªãch chuy·ªÉn m·∫Øt sang ph·∫£i
class DisplayAdapter {
private:  const int16_t OFFSET_X = 10;       // Gi·∫£m offset ƒë·ªÉ m·∫Øt n·∫±m gi·ªØa m√†n h√¨nh
  const int16_t PADDING_RIGHT = 40;  // D√†nh ch·ªó b√™n ph·∫£i 20px
  
  // Ki·ªÉm tra xem c√≥ v∆∞·ª£t qu√° v√πng hi·ªÉn th·ªã kh√¥ng
  bool isWithinBounds(int16_t x, int16_t w) {
    return (x + OFFSET_X + w <= tft.width() - PADDING_RIGHT);
  }
  
public:  void begin() {
    // TFT_eSPI handles initialization
  }
  void clearDisplay() {
    // NUCLEAR OPTION - X√≥a to√†n b·ªô m√†n h√¨nh m·ªói frame
    // ƒê√¢y l√† c√°ch duy nh·∫•t ƒë·ªÉ ƒë·∫£m b·∫£o 100% kh√¥ng c√≥ trailing
    extern uint16_t backgroundColor;
    tft.fillScreen(backgroundColor);
  }
  
  void display() {
    // TFT_eSPI updates immediately, no buffering needed
  }  void drawPixel(int16_t x, int16_t y, uint16_t color) {
    extern uint16_t backgroundColor;
    // ALWAYS clear pixel tr∆∞·ªõc khi v·∫Ω ƒë·ªÉ tr√°nh nhi·ªÖu
    tft.drawPixel(x + OFFSET_X, y, backgroundColor);
    if (isWithinBounds(x, 1)) {
      uint16_t tftColor = (color == 1) ? TFT_CYAN : backgroundColor;
      tft.drawPixel(x + OFFSET_X, y, tftColor);
    }
  }void fillRect(int16_t x, int16_t y, int16_t w, int16_t h, uint16_t color) {
    // Gi·ªõi h·∫°n width n·∫øu v∆∞·ª£t qu√° padding ph·∫£i
    int16_t maxWidth = tft.width() - PADDING_RIGHT - (x + OFFSET_X);
    if (maxWidth > 0) {
      w = min(w, maxWidth);
      extern uint16_t backgroundColor;
      uint16_t tftColor = (color == 1) ? TFT_CYAN : backgroundColor;
      tft.fillRect(x + OFFSET_X, y, w, h, tftColor);
    }
  }  void drawRect(int16_t x, int16_t y, int16_t w, int16_t h, uint16_t color) {
    // Gi·ªõi h·∫°n width n·∫øu v∆∞·ª£t qu√° padding ph·∫£i
    int16_t maxWidth = tft.width() - PADDING_RIGHT - (x + OFFSET_X);
    if (maxWidth > 0) {
      w = min(w, maxWidth);
      extern uint16_t backgroundColor;
      uint16_t tftColor = (color == 1) ? TFT_CYAN : backgroundColor;
      tft.drawRect(x + OFFSET_X, y, w, h, tftColor);
    }
  }  void fillCircle(int16_t x, int16_t y, int16_t r, uint16_t color) {
    if (isWithinBounds(x - r, 2 * r)) {
      extern uint16_t backgroundColor;
      uint16_t tftColor = (color == 1) ? TFT_CYAN : backgroundColor;
      tft.fillCircle(x + OFFSET_X, y, r, tftColor);
    }
  }
  void drawCircle(int16_t x, int16_t y, int16_t r, uint16_t color) {
    if (isWithinBounds(x - r, 2 * r)) {
      extern uint16_t backgroundColor;
      uint16_t tftColor = (color == 1) ? TFT_CYAN : backgroundColor;
      tft.drawCircle(x + OFFSET_X, y, r, tftColor);
    }
  }  void fillTriangle(int16_t x0, int16_t y0, int16_t x1, int16_t y1, int16_t x2, int16_t y2, uint16_t color) {
    // T√¨m x t·ªëi ƒëa c·ªßa tam gi√°c
    int16_t maxX = max(max(x0, x1), x2);
    if (maxX + OFFSET_X <= tft.width() - PADDING_RIGHT) {
      extern uint16_t backgroundColor;
      uint16_t tftColor = (color == 1) ? TFT_CYAN : backgroundColor;
      tft.fillTriangle(x0 + OFFSET_X, y0, x1 + OFFSET_X, y1, x2 + OFFSET_X, y2, tftColor);
    }
  }  void fillRoundRect(int16_t x, int16_t y, int16_t w, int16_t h, int16_t r, uint16_t color) {
    // Gi·ªõi h·∫°n width n·∫øu v∆∞·ª£t qu√° padding ph·∫£i
    int16_t maxWidth = tft.width() - PADDING_RIGHT - (x + OFFSET_X);
    if (maxWidth > 0) {
      w = min(w, maxWidth);
      extern uint16_t backgroundColor;
      uint16_t tftColor = (color == 1) ? TFT_CYAN : backgroundColor;
      tft.fillRoundRect(x + OFFSET_X, y, w, h, r, tftColor);
    }
  }
    void drawRoundRect(int16_t x, int16_t y, int16_t w, int16_t h, int16_t r, uint16_t color) {
    // Gi·ªõi h·∫°n width n·∫øu v∆∞·ª£t qu√° padding ph·∫£i
    int16_t maxWidth = tft.width() - PADDING_RIGHT - (x + OFFSET_X);
    if (maxWidth > 0) {
      w = min(w, maxWidth);
      extern uint16_t backgroundColor;
      uint16_t tftColor = (color == 1) ? TFT_CYAN : backgroundColor;
      tft.drawRoundRect(x + OFFSET_X, y, w, h, r, tftColor);
    }
  }
    // Tr·∫£ v·ªÅ k√≠ch th∆∞·ªõc c√≥ t√≠nh padding ƒë·ªÉ RoboEyes t√≠nh to√°n ƒë√∫ng
  int16_t width() { return tft.width() - OFFSET_X - PADDING_RIGHT; }  // 320 - 10 - 20 = 290px
  int16_t height() { return tft.height(); }  // 240px - k√≠ch th∆∞·ªõc ƒë·∫ßy ƒë·ªß
};

// Create display adapter instance (renamed to avoid conflict with RoboEyes)
DisplayAdapter displayAdapter;

// Create global display reference for FluxGarage RoboEyes library
DisplayAdapter& display = displayAdapter;

// Include FluxGarage RoboEyes library AFTER display is defined
#include <FluxGarage_RoboEyes.h>

// FluxGarage RoboEyes instance v·ªõi TFT_eSPI adapter
roboEyes eyes;

// Variables for background effects
uint16_t backgroundColor = TFT_BLACK;
String currentMood = "normal";
unsigned long lastMoodChange = 0;
unsigned long moodDuration = 5000; // 5 seconds

// Variables for eye movement tracking
static unsigned long lastEyeUpdate = 0;
static bool forceEyeClear = false;

// Force clear eye area (used when eyes move to prevent trailing)
void forceClearEyeArea() {
  // NUCLEAR CLEAR - X√≥a to√†n b·ªô m√†n h√¨nh
  tft.fillScreen(backgroundColor);
}

void setup() {
  Serial.begin(115200);
    // Initialize TFT
  tft.init();
  tft.setRotation(2); // Landscape 320x240
  tft.fillScreen(TFT_BLACK);  // Initialize RoboEyes v·ªõi k√≠ch th∆∞·ªõc ƒë·∫ßy ƒë·ªß m√†n h√¨nh
  eyes.begin(320, 240, 15);  // S·ª≠ d·ª•ng full screen, OFFSET s·∫Ω center m·∫Øt// Configure RoboEyes default settings cho 15 FPS
  eyes.setAutoblinker(true, 6, 10); // Auto blink every 6-10 seconds (ch·∫≠m h∆°n cho 15 FPS)
  eyes.setIdleMode(false);          // B·∫¨T idle mode ƒë·ªÉ c√≥ chuy·ªÉn ƒë·ªông t·ª± nhi√™n
  eyes.setCuriosity(true);         // B·∫¨T curiosity mode ƒë·ªÉ t·ª± ƒë·ªông nh√¨n xung quanh
    // Set larger eyes for TFT display
  eyes.setWidth(50, 50);           // Bigger eyes
  eyes.setHeight(50, 50);
  eyes.setBorderradius(12, 12);    // More rounded
  eyes.setSpacebetween(30);        // More space between eyes
    // C·ªê ƒê·ªäNH v·ªã tr√≠ m·∫Øt ·ªü trung t√¢m ban ƒë·∫ßu
  eyes.setPosition(DEFAULT);       // Set to center position
  
  Serial.println("=== ESP32 Emotional Pet with FluxGarage RoboEyes ===");
  Serial.println("TFT_eSPI + FluxGarage RoboEyes Integration");
  Serial.println("");
  Serial.println("Commands:");
  Serial.println(":happy - Happy mood");
  Serial.println(":angry - Angry mood");
  Serial.println(":tired - Tired mood");
  Serial.println(":normal - Normal mood");
  Serial.println("");
  Serial.println("Animations:");
  Serial.println(":confused - Confused animation");
  Serial.println(":laugh - Laugh animation");
  Serial.println(":blink - Manual blink");
  Serial.println(":wink - Wink (left eye)");
  Serial.println("");
  Serial.println("Look directions:");
  Serial.println(":look:N/NE/E/SE/S/SW/W/NW/CENTER");
  Serial.println("");
  Serial.println("Settings:");
  Serial.println(":idle:1/0 - Toggle idle mode");
  Serial.println(":auto:1/0 - Toggle auto blink");
  Serial.println(":cyclops:1/0 - Toggle cyclops mode");
  Serial.println(":curious:1/0 - Toggle curiosity mode");
  Serial.println("=========================================================");
}

void loop() {
  // Handle serial commands
  if (Serial.available()) {
    String command = Serial.readStringUntil('\n');
    command.trim();
    Serial.println("DEBUG: Raw command = '" + command + "'");
    handleCommand(command);
  }
  
  // REDUCED clearing strategy - ch·ªâ clear khi c·∫ßn thi·∫øt
  static unsigned long lastClear = 0;
  if (millis() - lastClear > 50) { // Clear m·ªói 50ms thay v√¨ m·ªói frame
    tft.fillScreen(backgroundColor);
    lastClear = millis();
  }
  
  // Update RoboEyes (this handles all animations and drawing)
  eyes.update();
  
  delay(33); // 30 FPS
}

void handleCommand(String command) {
  command.toLowerCase();
  Serial.println("Received: " + command);
  Serial.println("DEBUG: Command length = " + String(command.length()));
  
  // Mood commands
  if (command == ":happy") {
    Serial.println("DEBUG: Processing :happy command");
    eyes.setMood(HAPPY);
    backgroundColor = TFT_YELLOW;
    currentMood = "happy";
    Serial.println("Mood: Happy üòä");
    
  } else if (command == ":angry") {
    Serial.println("DEBUG: Processing :angry command");
    eyes.setMood(ANGRY);
    backgroundColor = TFT_RED;
    currentMood = "angry";
    Serial.println("Mood: Angry üò†");
    
  } else if (command == ":tired") {
    Serial.println("DEBUG: Processing :tired command");
    eyes.setMood(TIRED);
    backgroundColor = TFT_NAVY;
    currentMood = "tired";    Serial.println("Mood: Tired üò¥");
    
  } else if (command == ":normal") {
    eyes.setMood(DEFAULT);
    backgroundColor = TFT_BLACK;
    currentMood = "normal";
    Serial.println("Mood: Normal üòê");
    
  // Animation commands
  } else if (command == ":confused") {
    tft.fillScreen(backgroundColor); // Nuclear clear BEFORE animation
    eyes.anim_confused();
    Serial.println("Animation: Confused üòµ");
    
  } else if (command == ":laugh") {
    tft.fillScreen(backgroundColor); // Nuclear clear BEFORE animation
    eyes.anim_laugh();
    Serial.println("Animation: Laugh üòÇ");
    
  } else if (command == ":blink") {
    tft.fillScreen(backgroundColor); // Nuclear clear BEFORE animation
    eyes.blink();
    Serial.println("Animation: Blink üòâ");
    
  } else if (command == ":wink") {
    tft.fillScreen(backgroundColor); // Nuclear clear BEFORE animation    eyes.blink(true, false); // Only left eye
    Serial.println("Animation: Wink üòâ");
    
  // Look direction commands
  } else if (command.startsWith(":look:")) {String direction = command.substring(6);
    direction.toUpperCase();    
    tft.fillScreen(backgroundColor); // Nuclear clear BEFORE eye movement
    
    if (direction == "N") {
      eyes.setPosition(N);
      Serial.println("Looking: North ‚¨ÜÔ∏è");
    } else if (direction == "NE") {
      eyes.setPosition(NE);
      Serial.println("Looking: North-East ‚ÜóÔ∏è");
    } else if (direction == "E") {
      eyes.setPosition(E);
      Serial.println("Looking: East ‚û°Ô∏è");
    } else if (direction == "SE") {
      eyes.setPosition(SE);
      Serial.println("Looking: South-East ‚ÜòÔ∏è");
    } else if (direction == "S") {
      eyes.setPosition(S);
      Serial.println("Looking: South ‚¨áÔ∏è");
    } else if (direction == "SW") {
      eyes.setPosition(SW);
      Serial.println("Looking: South-West ‚ÜôÔ∏è");
    } else if (direction == "W") {
      eyes.setPosition(W);
      Serial.println("Looking: West ‚¨ÖÔ∏è");
    } else if (direction == "NW") {
      eyes.setPosition(NW);
      Serial.println("Looking: North-West ‚ÜñÔ∏è");
    } else if (direction == "CENTER") {
      eyes.setPosition(DEFAULT);
      Serial.println("Looking: Center üëÄ");    } else {
      Serial.println("Invalid direction. Use: N/NE/E/SE/S/SW/W/NW/CENTER");
    }
    
  // Settings commands
  } else if (command.startsWith(":idle:")) {
    int value = command.substring(6).toInt();
    eyes.setIdleMode(value == 1);
    Serial.println("Idle mode: " + String(value == 1 ? "ON (m·∫Øt s·∫Ω di chuy·ªÉn)" : "OFF (m·∫Øt c·ªë ƒë·ªãnh)"));
    
  } else if (command.startsWith(":auto:")) {
    int value = command.substring(6).toInt();
    eyes.setAutoblinker(value == 1);
    Serial.println("Auto blink: " + String(value == 1 ? "ON" : "OFF"));
    
  } else if (command.startsWith(":cyclops:")) {
    int value = command.substring(9).toInt();
    eyes.setCyclops(value == 1);
    Serial.println("Cyclops mode: " + String(value == 1 ? "ON" : "OFF"));
    
  } else if (command.startsWith(":curious:")) {
    int value = command.substring(9).toInt();
    eyes.setCuriosity(value == 1);
    Serial.println("Curiosity mode: " + String(value == 1 ? "ON (t·ª± ƒë·ªông nh√¨n xung quanh)" : "OFF (kh√¥ng t·ª± ƒë·ªông nh√¨n)"));
    
  } else {
    Serial.println("‚ùå Unknown command!");
    Serial.println("üìã Available commands:");
    Serial.println("   Moods: :happy, :angry, :tired, :normal");
    Serial.println("   Animations: :confused, :laugh, :blink, :wink");
    Serial.println("   Look: :look:N/NE/E/SE/S/SW/W/NW/CENTER");
    Serial.println("   Settings: :idle:1/0, :auto:1/0, :cyclops:1/0, :curious:1/0");
  }
  
  lastMoodChange = millis();
}

void updateBackground() {
  // Simplified background - CH·ªà fill c√°c g√≥c ƒë·ªÉ tr√°nh conflict v·ªõi eye area
  static uint16_t currentBgColor = TFT_BLACK;
  static unsigned long lastBgUpdate = 0;
  
  // Ch·ªâ update background khi mood thay ƒë·ªïi
  if (millis() - lastBgUpdate > 200 && currentBgColor != backgroundColor) { 
    currentBgColor = backgroundColor;
    
    // CH·ªà fill 4 g√≥c m√†n h√¨nh ƒë·ªÉ tr√°nh conflict v·ªõi eye area
    // Top corners
    tft.fillRect(0, 0, 320, 25, currentBgColor);
    // Bottom corners 
    tft.fillRect(0, 215, 320, 25, currentBgColor);
    // Left side
    tft.fillRect(0, 25, 15, 190, currentBgColor);
    // Right side
    tft.fillRect(305, 25, 15, 190, currentBgColor);
    
    lastBgUpdate = millis();
  }
  
  // LO·∫†I B·ªé mood effects ƒë·ªÉ tr√°nh xung ƒë·ªôt
}
